# Java Native Interface

Java provides a standard programming interface for interacting with functions from external native libraries. Although the naming conventions and internals differ for dynamic libraries across platforms, each conforming Java virtual machine (JVM) implementation supports JNI: [Java native interface](http://en.wikipedia.org/wiki/Java_Native_Interface). See [Oracle JNI doc](http://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html).

The basic idea is that the Java code specifies the Java interface part without a body by using the `native` keyword. Then, the `javah` tool is used to create an include file with all of the appropriate definitions for some C code to define the appropriate native method.

## Disadvantages of Native Methods

The most common disadvantages of using native methods include:

* Loss of portability 
* Security restrictions prevent their use in things like Applets
* Software dependencies on multiple programming languages means devs need to know more than Java
* More complicated build
* Hassle of distributing software with OS-dependent, native libraries

## JNI support files location

See the include directory:

```
<install-directory>/include/
<install-directory>/include/<platform-directory>/
```

Principal files:

```
<install-directory>/include/jni.h
<install-directory>/include/<platform-directory>/jni_md.h
```

This header files account for the platform dependencies with C and C++. Each Java distribution provides an include directory with the header files that map Java data types to JNI data types to C data types. This mapping is handled in `jni.h`:

```c
...
typedef unsigned char   jboolean;
typedef unsigned short  jchar;
typedef short           jshort;
typedef float           jfloat;
typedef double          jdouble;
...
```

Platform dependent data types are handled in a separate header file, `jni_md.h`:

```c
#define JNIEXPORT     __attribute__((visibility("default")))
#define JNIIMPORT     __attribute__((visibility("default")))
#define JNICALL

typedef int jint;
#ifdef _LP64 /* 64-bit */
typedef long jlong;
#else
typedef long long jlong;
#endif

typedef signed char jbyte;
```

The `jni.h` header file contains various convenience definitions that are useful in describing method/function signatures, field types, and so on.

```c
typedef union jvalue {
    jboolean z;
    jbyte    b;
    jchar    c;
    jshort   s;
    jint     i;
    jlong    j;
    jfloat   f;
    jdouble  d;
    jobject  l;
} jvalue;
```

## Hello world from Java to C

```java
public class HelloJNI {
	static {
		// Load native library dynamically
		System.loadLibrary("hello"); 
	}

	native void sayHello();

	public static void main(String[] args) {
		HelloJNI hello = new HelloJNI();
		hello.sayHello();
	}
}
```

Then we fill in the definition of `Java_HelloJNI_sayHello`:

```c
#include <jni.h>
#include <stdio.h>
#include "HelloJNI.h"

// Implementation of native method 'void sayHello()' from HelloJNI
JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {
   printf("Hello World!\n");
   return;
}
```

To build/link, do this on a Mac (`jdk1.8.0.jdk` might be different):


```bash
$ javac HelloJNI.java
$ javah HelloJNI
$ ls
HelloJNI.class   HelloJNI.java    hello.h
HelloJNI.h       hello.c          libhello.jnilib*
$ cc -dynamiclib -o libhello.jnilib \
  -I/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/include \
  -I/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/include/darwin \
  hello.c
$ java HelloJNI
Hello World!
```

According to this [blog entry](https://blogs.oracle.com/moonocean/entry/a_simple_example_of_jni), Linux uses prefix `lib` and suffix `.so`:

```bash
$ gcc -shared -fpic -o libfoo.so -I/usr/java/include -I/usr/java/include/linux foo.c
```

On Windows OS, it is prefixed by nothing and suffixed with '.dll'. It could be compiled with Visual Studio automatically and create a file named as foo.dll. 


## Return a C string to Java

```java
public class GetTime {
	static {
		// Load native library dynamically
		System.loadLibrary("gettime"); 
	}

	public native String getTime();

	public static void main(String[] args) {
		System.out.println(new GetTime().getTime());
	}
}
```
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class GetTime */

#ifndef _Included_GetTime
#define _Included_GetTime
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     GetTime
 * Method:    getTime
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_GetTime_getTime
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

What is a `jstring`? From `jni.h`:

```c
// C defs
struct _jobject;
...
typedef jobject jstring;
```

```c
#include <jni.h>
#include <stdio.h>
#include <time.h>
#include "GetTime.h"

#define TIME_STR_LEN 200

JNIEXPORT jstring JNICALL Java_GetTime_getTime(JNIEnv *env, jobject obj)
{
    static char timeStr[TIME_STR_LEN];
    static jstring jtime;
    time_t current;
    struct tm *t;

    current = time((time_t *) NULL);
    t = localtime(&current);
    sprintf(timeStr, "The current time is: %02d:%02d:%02d.\n",
    t->tm_hour, t->tm_min, t->tm_sec);
    jtime = (*env)->NewStringUTF(env, timeStr);
    return jtime;
}
```

```bash
cc -dynamiclib -o libgettime.jnilib -I/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/include/darwin gettime.c
$ java GetTime
The current time is: 11:26:52.
```

## Access Java array in C

```java
// http://www.math.uni-hamburg.de/doc/java/tutorial/native1.1/implementing/array.html
class SumArray {
    static { System.loadLibrary("sum"); }

    native int sumArray(int arr[]);

    public static void main(String args[]) {
        SumArray s = new SumArray();
        int arr[] = new int [10];
        for (int i = 0; i < 10; i++) {
            arr[i] = i;
        }
        int sum = s.sumArray(arr);
        System.out.println("sum = " + sum);
    }
}
```

Cannot use just plain `a[i]` in C; must use `GetArrayLength`, `GetIntArrayElements`, and `ReleaseIntArrayElements`:

```c
#include <jni.h>
#include "SumArray.h"

// http://www.math.uni-hamburg.de/doc/java/tutorial/native1.1/implementing/array.html
JNIEXPORT jint JNICALL 
Java_SumArray_sumArray(JNIEnv *env, jobject obj, jintArray arr)
{
    jsize len = (*env)->GetArrayLength(env, arr);
    int i, sum = 0;
    jint *body = (*env)->GetIntArrayElements(env, arr, 0); // 
    for (i=0; i<len; i++) {
	    sum += body[i];
    }
    (*env)->ReleaseIntArrayElements(env, arr, body, 0);
    return sum;
}
```

From Oracle/Sun java tutorial:

<blockquote>
While, in general, Java arrays may be moved by the garbage collector, the Virtual Machine guarantees that the result of GetIntArrayElements points to a nonmovable array of integers. The JNI will either "pin" down the array , or it will make a copy of the array into nonmovable memory. When the native code has finished using the array, it must call ReleaseIntArrayElements.
</blockquote>

Now build and run:

```
$ cc -dynamiclib -o libsum.jnilib \
  -I/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/include \
  -I/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/include/darwin \
  sum.c
$ java SumArray
sum = 45
```

## Call static native method

```java
public class CallStatic {
    static { System.loadLibrary("statichello"); }

    static native void sayHello();

    public static void main(String[] args) {
        sayHello();
    }
}
```

```c
#include <jni.h>
#include <stdio.h>
#include "CallStatic.h"
 
// instance method version:
//JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) { ... }

// static method
JNIEXPORT void JNICALL Java_CallStatic_sayHello(JNIEnv *env, jclass thisClass) {
   printf("Hello World!\n");
   return;
}
```

```bash
$ cc -dynamiclib -o libsum.jnilib \
  -I/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/include \
  -I/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/include/darwin \
  statichello.c
```
